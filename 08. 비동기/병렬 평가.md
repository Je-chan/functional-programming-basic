# 1. 지연된 함수열을 병렬적으로 평가
- 자바스크립트가 동작하는 환경에서는 비동기 IO 로 동작
  - 싱글 스레드 기반, IO 를 동기가 아닌 비동기로 처리해서 하나의 스레드에서도 CPU 점유하는 것들을 효율적으로 활용
- 그러면 자바스크립트에서 병렬적인 로직을 할 필요는 없지 않은가?
  - 사실 자바스크립트가 어떤 로직을 제어하는 것을 비동기적으로 제어할 뿐
  - 얼마든지 병렬적인 처리를 진행할 수 있음
  - DB 를 병렬적으로 출발시켜 결과를 한 번에 얻어 오거나
  - NoSQL 를 쓸 때 여러 키로 여러 값을 받아 처리한다든지 등
- NodeJS 가 직접 해당하는 일을 처리하는 것이 아니라 네트워크나 기타 IO 로 작업을 보내놓고 대기하고 시점을 다루는 일들을 NodeJS 가 하는 것
- 즉, 동시에 출발 시켰다가 하나로 귀결시키는 등의 로직은 개발자의 역할
- 동시성으로 동작하는 병렬성

```typescript
const delay1000 = (a) => {
  console.log('hello!')
	new Promise((resolve) => setTimeout(() => resolve(a), 1000));
}
// 기존에 사용하는 map, filter 는 모든 배열의 요소를 검토, 평가한 후 다음 함수의 인자로 넘기게 됨
go(
	[1, 2, 3, 4, 5],
	map(a => delay500(a * a)), 
  filter(a => a % 2),
  reduce(add),
  console.log
)

// 하지만 지연 평가 함수들을 사용하면, L.filter 로 걸러지는 것들은 reduce 로 넘기지 않게 되고 각 요소는 평가하지 않음
// 지연 평가란 말 그대로 L.map, L.filter 는 함수를 사실상 실행하지 않은 상태인 것
console.time('')
go(
	[1, 2, 3, 4, 5],
  L.map(a => delay1000(a * a)),
  L.filter(a => a % 2),
  reduce(add),
  console.log,
  _ => console.timeEnd('') // : 5013.5771484375ms
)

// 콘솔 내용은 아래 hello 가 500ms 때마다 하나씩 찍힐 것
/* 
 *  hello!
 *  hello!
 *  hello!
 *  hello!
 *  hello!
 *  35
 */
```
- 여기에서 go() 안에 있는 함수들은 순차적으로 실행
- 그런데 만일, 함수들을 동시에 출발 시킨 다음에 reduce(add) 를 하게 된다면
  - 부하는 생길 수 있다는 단점이 있지만
  - 특정 상황에서는 빠르게 최종 결과를 만들 수 있는 상황이 생길 수 있음

```typescript
export const C = {};

// [...iter], [...acc] 를 한다는 건 대기된 함수를 모두 다 실행한다는 것
// > 비동기가 일어나는 것을 제외하지 않고 모든 것을 실행함
// > 다 실행하고 나서 다시 한 번 reduce 에서 순회하면서 값을 꺼낼 것
// > 기존의 reduce 는 배열의 요소 하나씩 순회하고, reduce 이전의 함수들을 거쳐 평가된 값을 인자로 받겠지만
// > C.reduce 는 모든 것을 다 실행하고, 다시 그 평가된 배열에서 요소를 개별적으로 비동기 제어해서 누적
C.reduce = curry((f, acc, iter) =>
  iter ? reduce(f, acc, [...iter]) : reduce(f, [...acc])
);

console.time('')
go(
	[1, 2, 3, 4, 5],
	L.map(a => delay1000(a * a)),
	L.filter(a => a % 2),
	C.reduce(add),
	console.log,
	_ => console.timeEnd('') // : 1005.94921875ms
)
/* 
 *  (5) hello!
 *  35
 */
```
- 시간도 좀더 빠르게 될 것