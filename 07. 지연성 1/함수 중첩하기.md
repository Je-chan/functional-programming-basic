# 1. 즉시 평가 함수 중첩
## 즉시 평가 함수 집합
```typescript
const curry = f => (a, ..._) => _.length ? f(a, ..._) : (..._) => f(a, ..._);

const range = l => {
	let i = -1;
	let res = [];
	while(++i < l) {
		res.push(i)
  }
	return res;
}

const map = curry((f, iter) => {
	let res = []
  // for(const a of iter) {
	// 	res.push(f(a))
  // }
  
  // for 문을 좀 더 상세하게 대체를 하면 아래의 코드가 탄생
  iter = iter[Symbol.iterator]()
  let cur
  while(!(cur = iter.next()).done) {
		const a = cur.value
    res.push(f(a))
  }
	return res
})

const filter = curry((f, iter) => {
	let res = [];
	// for(const a of iter) {
	// 	res.push(a);
	// 	if(res.lenght === l) return res
  // }
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		if(f(a)) res.push(f(a))
	}
	return res
})

const take = curry((l, iter) => {
	let res = []
  // for(const a of iter) {
	// 	res.push(a)
  //   if(res.length === l) return res
  // }
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		res.push(a)
		if(res.length === l) return res
	}
	return res
})

const reduce = curry((f, acc, iter) =>{ 
	if(!iter) {
		iter = acc[Symbol.iterator]();
		acc = iter.next().value
  } else {
		iter = iter[Symbol.iterator]()
	}
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		acc = f(acc, a)
  }
	return acc
})

const go = (...args) => reduce((initValue, f) => f(initValue), args);
```

## 중첩하기
```typescript
go(
	range(10), // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 를 리턴
  map(n => n + 10), // [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 를 리턴
  filter(n => n % 2), // [11, 13, 15, 17, 19] 를 리턴
  take(2), // [11, 13] 을 리턴
  console.log
)
```

# 2. 지연 평가 함수 중첩
## 지연 평가 함수 집합
```typescript

let L = {}

L.range = function *(l) {
	let i = -1;
	while(++i < l) {
		yield i;
  }
}

L.map = curry(function *(f, iter) {
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		yield f(a)
  }
})

L.filter = curry(function *(f, iter) {
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		if(f(a)) {
			yield a;
    }
  }
})


```

## 중첩하기
```typescript
go(
	L.range(10),
	L.map(n => n + 10),
  L.filter(n => n % 2),
  take(2),
  console.log
)
```