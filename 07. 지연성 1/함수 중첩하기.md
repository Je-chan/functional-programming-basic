# 1. 즉시 평가 함수 중첩
## 즉시 평가 함수 집합
```typescript
const curry = f => (a, ..._) => _.length ? f(a, ..._) : (..._) => f(a, ..._);

const range = l => {
	let i = -1;
	let res = [];
	while(++i < l) {
		res.push(i)
  }
	return res;
}

const map = curry((f, iter) => {
	let res = []
  // for(const a of iter) {
	// 	res.push(f(a))
  // }
  
  // for 문을 좀 더 상세하게 대체를 하면 아래의 코드가 탄생
  iter = iter[Symbol.iterator]()
  let cur
  while(!(cur = iter.next()).done) {
		const a = cur.value
    res.push(f(a))
  }
	return res
})

const filter = curry((f, iter) => {
	let res = [];
	// for(const a of iter) {
	// 	res.push(a);
	// 	if(res.lenght === l) return res
  // }
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		if(f(a)) res.push(f(a))
	}
	return res
})

const take = curry((l, iter) => {
	let res = []
  // for(const a of iter) {
	// 	res.push(a)
  //   if(res.length === l) return res
  // }
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		res.push(a)
		if(res.length === l) return res
	}
	return res
})

const reduce = curry((f, acc, iter) =>{ 
	if(!iter) {
		iter = acc[Symbol.iterator]();
		acc = iter.next().value
  } else {
		iter = iter[Symbol.iterator]()
	}
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		acc = f(acc, a)
  }
	return acc
})

const go = (...args) => reduce((initValue, f) => f(initValue), args);
```

## 중첩하기
```typescript
go(
	range(10), // (1) [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 를 리턴
  map(n => n + 10), // (2) [10, 11, 12, 13, 14, 15, 16, 17, 18, 19] 를 리턴
  filter(n => n % 2), // (3) [11, 13, 15, 17, 19] 를 리턴
  take(2), // (4) [11, 13] 을 리턴
  console.log
)
```
- 평가 순서는 (1) => (2) => (3) => (4)

# 2. 지연 평가 함수 중첩
## 지연 평가 함수 집합
```typescript

let L = {}

L.range = function *(l) {
	let i = -1;
	while(++i < l) {
		yield i;
  }
}

L.map = curry(function *(f, iter) {
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		yield f(a)
  }
})

L.filter = curry(function *(f, iter) {
	iter = iter[Symbol.iterator]()
	let cur
	while(!(cur = iter.next()).done) {
		const a = cur.value
		if(f(a)) {
			yield a;
    }
  }
})


```

## 중첩하기
```typescript
go(
	L.range(10), // (1) (7)
	L.map(n => n + 10), // (2) (6) (8)
  L.filter(n => n % 2), // (3) (5) (9)
  take(2), // (4) Generator{<suspend>} 를 인자로 받고 (10) 
  console.log // (11)
)
```
- 함수 실행 순서는 분명 L.range, L.map, L.filter, take 순서지만
- 평가의 첫 시작은 take 에서 시작한다.
  - (1) L.range 의 결과가 평가가 되기를 미룬 Generator 가 L.map으로 들어감
  - (2) L.map 도 평가가 되기를 미룬 Generator 가 L.filter 로 들어감
  - (3) L.filter 도 평가가 되기를 미룬 Generator 가 take 로 들어감
  - (4) take 가 평가됨 
  - (5) L.filter 를 평가를 위해 while 문 들어가기 전 iter.next() 가 L.map 함수의 Generator 메소드를 실행하므로 L.map 함수로 들어간다
  - (6) L.map 을 평가하기 위해 while 문 들어가기 전 iter.next() 가 L.range 함수의 Generator 메소드를 실행하므로 L.range 함수로 들어간다
  - (7) L.range 에서 비로소 i 값이 평가된다 
  - (8) L.range 에서 평가된 값이 L.map 으로 들어가 평가된다
  - (9) L.map 에서 평가된 값이 L.filter 로 들어가 평가된다
  - (10) L.filter 에서 평가된 값이 take iter.next() 가 반환하는 값으로 들어가서 
    - (10-1) take 가 Return 하지 못한다면 (7) 로 다시 돌아가 작업한다
    - (10-2) take 가 Return 한다면 다음 함수로 넘어간다
  - (11) console.log 를 찍는다