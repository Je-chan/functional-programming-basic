# 1. go
- 함수형 프로그래밍에서는 코드를 값으로 다룰 수 있기 때문에 평가하는 시점을 원하는 대로 다뤄 코드의 표현력을 높일 수 있다
- "go" 는 함수를 여러 개 받아서 함수를 순차적으로 진행할 수 있는 함수
- 즉시 값을 평가
```typescript
const go = (...args) => reduce((initValue, f) => f(initValue), args);
```

# 2. pipe
- 함수를 리턴하는 함수
- 나열된 함수를 합성하는 함수
- go 를 활용해서 만들 수 있음
```typescript
const pipe = (f, ...fList) => (...aList) => go(f(...aList), ...fs);
```

# 3. 사용 예제
```typescript
const products = [
  {name: 'Keychron', price: 120000},
  {name: 'KN01C', price: 130000},
  {name: '660C', price: 230000},
  {name: 'R2', price: 270000},
  {name: 'R3 Silent', price: 390000},
]

const filter = (f, iterable) => {
  let result = [];

  for (const a of iterable) {
    if(f(a)) result.push(a)
  }

  return result
}

const map = (f, iterator) => {
  let result = [];

  for(const item of iterator) {
    result.push(f(item));
  }

  return result
}

const reduce = (f, acc, iterator) => {
  if(!iterator) {
    iterator = acc[Symbol.iterator]()
    acc = iterator.next().value
  }
  for (const a of iterator) {
    acc = f(acc, a)
  }
  return acc
}

const add = (a, b) => a + b

reduce(add, map(p => p.price, filter(p => p.price >= 200000, products)))
```
- 위의 reduce 로 시작하는 표현식을 go로 사용해 깔끔하고 읽기 쉽게 표현할 수 있다.
```typescript
go (
  products,
  products => filter(p => p.price >= 200000, products),
  products => map(p => p.price, products),
  prices => reduce(add, prices),
  console.log
)
```
